# Задачи FreeRTOS

Этот каталог содержит все задачи верхнего уровня проекта USB Floppy Emulator.

## Архитектура

Проект использует **FreeRTOS** с частотой переключения задач **10 кГц** (10000 переключений/сек) для обеспечения быстрой реакции на события от энкодера и стабильной работы USB.

### Схема взаимодействия задач

```
┌──────────────┐
│ control_task │ (Приоритет 4 - Высший)
└──────┬───────┘
       │ События управления
       ▼
┌──────────────┐     Команды     ┌──────────────┐
│  menu_task   │◄───────────────►│  oled_task   │ (Приоритет 2)
└──────┬───────┘   отображения   └──────────────┘
       │
       │ Запросы файлов/загрузка
       ▼
┌──────────────┐                 ┌──────────────┐
│ sdcard_task  │◄───────────────►│   usb_task   │ (Приоритет 3)
└──────────────┘  Чтение/запись  └──────────────┘
       │          секторов
       │
       ▼
┌──────────────┐
│   led_task   │ (Приоритет 1 - Низший)
└──────────────┘
```

## Описание задач

### 1. **control_task** (Приоритет 4)
**Файлы:** `control_task.h`, `control_task.c`

Отвечает за опрос энкодера или кнопок и генерацию событий управления.

- **Вход**: GPIO (энкодер/кнопки)
- **Выход**: Очередь `menu_queue` с событиями
- **Частота опроса**: 1 кГц (каждую 1 мс)
- **События**:
  - `CONTROL_EVENT_UP` / `CONTROL_EVENT_DOWN`
  - `CONTROL_EVENT_ENCODER_CW` / `CONTROL_EVENT_ENCODER_CCW`
  - `CONTROL_EVENT_OK`
  - `CONTROL_EVENT_LONG_PRESS`

**Особенности:**
- Реализован дебаунс кнопок (50 мс по умолчанию)
- Алгоритм декодирования энкодера с микрошагами
- Высокий приоритет для мгновенной реакции

---

### 2. **menu_task** (Приоритет 2)
**Файлы:** `menu_task.h`, `menu_task.c`

Центральная логика меню - обрабатывает события управления и координирует работу UI.

- **Вход**: Очередь `menu_queue` (от control_task)
- **Выход**: Очереди `oled_queue`, `sdcard_queue`
- **Состояния**:
  - `MENU_STATE_MAIN` - главное меню
  - `MENU_STATE_FILE_LIST` - список образов
  - `MENU_STATE_FILE_SELECTED` - подтверждение выбора
  - `MENU_STATE_LOADING` - загрузка образа
  - `MENU_STATE_ERROR` - ошибка

**Особенности:**
- Автоматическая прокрутка списка
- Поддержка разных высот дисплея (32/64 px)
- Асинхронное взаимодействие с SD картой

---

### 3. **oled_task** (Приоритет 2)
**Файлы:** `oled_task.h`, `oled_task.c`

Управление OLED дисплеем SSD1306 через I2C.

- **Вход**: Очередь `oled_queue` с командами отрисовки
- **Выход**: I2C (дисплей)
- **Команды**:
  - `OLED_CMD_CLEAR` - очистка
  - `OLED_CMD_UPDATE_MENU` - обновление меню
  - `OLED_CMD_SHOW_MESSAGE` - вывод сообщения
  - `OLED_CMD_SHOW_STATUS` - статусная строка
  - `OLED_CMD_POWER_ON` / `OLED_CMD_POWER_OFF`

**Особенности:**
- Неблокирующая работа через очередь
- Поддержка дисплеев 128x32 и 128x64

---

### 4. **sdcard_task** (Приоритет 2)
**Файлы:** `sdcard_task.h`, `sdcard_task.c`

Работа с SD картой через SPI и файловой системой FatFS.

- **Вход**: Очередь `sdcard_queue` с командами
- **Выход**: SPI (SD карта), очередь `sdcard_response_queue`
- **Команды**:
  - `SDCARD_CMD_INIT` - инициализация карты
  - `SDCARD_CMD_LIST_IMAGES` - сканирование .img файлов
  - `SDCARD_CMD_LOAD_IMAGE` - загрузка образа
  - `SDCARD_CMD_READ_SECTOR` / `SDCARD_CMD_WRITE_SECTOR`
  - `SDCARD_CMD_EJECT` - извлечение диска

**Особенности:**
- Интеграция с FatFS
- API функции для прямого доступа: `sdcard_read_sector()`, `sdcard_write_sector()`
- Кэширование метаданных файлов

---

### 5. **usb_task** (Приоритет 3)
**Файлы:** `usb_task.h`, `usb_task.c`

Эмуляция USB Mass Storage Device через TinyUSB.

- **Вход**: Очередь `usb_queue`, вызовы от TinyUSB
- **Выход**: USB, запросы к `sdcard_task`
- **Частота**: Вызов `tud_task()` каждые 100 мкс
- **Команды**:
  - `USB_CMD_MOUNT` - подключить диск
  - `USB_CMD_UNMOUNT` - отключить
  - `USB_CMD_EJECT` - извлечь

**Особенности:**
- Высокий приоритет для стабильности USB
- Callbacks для TinyUSB:
  - `tud_msc_read10_cb()` - чтение секторов
  - `tud_msc_write10_cb()` - запись секторов
  - `tud_msc_capacity_cb()` - емкость диска (1.44 MB)
  - `tud_msc_test_unit_ready_cb()` - готовность

---

### 6. **led_task** (Приоритет 1)
**Файлы:** `led_task.h`, `led_task.c`

Управление встроенным светодиодом для индикации состояния.

- **Вход**: Очередь `led_queue` с командами
- **Выход**: GPIO (LED_PIN)
- **Режимы**:
  - `LED_MODE_OFF` / `LED_MODE_ON`
  - `LED_MODE_BLINK_SLOW` - 1 Гц
  - `LED_MODE_BLINK_FAST` - 5 Гц
  - `LED_MODE_PULSE` - пульсация
  - `LED_MODE_ACTIVITY` - короткая вспышка

**API:**
```c
led_set_mode(LED_MODE_BLINK_SLOW);
led_activity();  // Вспышка при операции
```

---

## Приоритеты задач

| Задача       | Приоритет | Стек | Описание                          |
|--------------|-----------|------|-----------------------------------|
| control_task | 4         | 256  | Максимальная реакция на ввод      |
| usb_task     | 3         | 1024 | Критичность для USB               |
| menu_task    | 2         | 512  | Обработка UI логики               |
| oled_task    | 2         | 512  | Отрисовка дисплея                 |
| sdcard_task  | 2         | 1024 | Работа с файлами                  |
| led_task     | 1         | 256  | Индикация (фоновая задача)        |

## Использование очередей

Все задачи общаются через **очереди FreeRTOS**:

```c
// Отправка события в меню
menu_message_t msg = {.event = CONTROL_EVENT_OK};
xQueueSend(menu_queue, &msg, portMAX_DELAY);

// Отправка команды на OLED
oled_message_t oled_msg = {.command = OLED_CMD_CLEAR};
xQueueSend(oled_queue, &oled_msg, 0);
```

## Инициализация

Все задачи инициализируются из главного файла:

```c
#include "tasks.h"

int main() {
    // Инициализация Pico SDK
    stdio_init_all();
    
    // Инициализация всех задач
    tasks_init_all();
    
    // Запуск планировщика FreeRTOS
    vTaskStartScheduler();
}
```

## TODO

- [ ] Реализовать интеграцию с pico-ssd1306
- [ ] Подключить FatFS к sdcard_task
- [ ] Настроить TinyUSB для Mass Storage
- [ ] Добавить обработку ошибок через event groups
- [ ] Реализовать кэширование секторов в sdcard_task
- [ ] Добавить режим энергосбережения для OLED
